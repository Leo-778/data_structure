

# 排序

## 一、定义与评价指标

### 1、内排序和外排序的区别

排序（Sort）：就是重新排列表中的元素，使表中的元素满⾜按关键字有序的过程。

内部排序：数据都在内存中。（关注如何使算法的时间、空间复杂度更低）

外部排序：待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中**需要对外存进行访问**的排序过程。（关注如何减少 IO 次数）

### 2、算法的评价指标：

- **空间复杂度** 

- **时间复杂度** 

- ⭐**稳定性：** 若待排序表中有两个元素 R_i 和 R_j ，其对应的关键字相同即 key_i = key_j ，且在排序前 R_i 在 R_j 的前⾯，若使⽤某⼀排序算法排序后，R_i 仍然在 R_j 的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。

## 二、内部排序

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;
//打印测试函数
void print(int a[], int n ,int i){
    printf("%d:",i);
    for(int j=0; j<8; j++){
        printf("%d",a[j]);
    }
    printf("\n");
}

//测试数据
int main(int argc, char const *argv[])
{
    int a[10] = {3, 2, 7, 6, 5, 8, 4, 1, 9, 0};
    Sort(a, 10);
    return 0;
}
```

### 1、插入排序

-  **直接插入排序**

**算法思想：**每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中， 直到全部记录插⼊完成。

**示意图：**

<img src="D:\Files\VS-code\c and c++\Data Structure\Sort\img\插入排序.gif" alt="插入排序" style="zoom:70%;" />

**代码实现：**

```c++
//插入排序
void InsertSort(int *a,int n){
    int temp;
    for (int i = 1; i <= n; i++)
    {
        temp = a[i];
        int j=i;
        while (temp < a[j - 1])
        {
            a[j ] = a[j-1];
            j--;
        }
        a[j] = temp;
        print(a, 10, i);
    }
}
```

```tex
输出：
1:2376584190
2:2376584190
3:2367584190
4:2356784190
5:2356784190
6:2345678190
7:1234567890
8:1234567890
9:0123456789
```

**算法效率分析：** 

​	空间复杂度：O(1)

​	最好时间复杂度（全部有序）：O(n) 

​	最坏时间复杂度（全部逆序）：O(n^2) 

​	平均时间复杂度：O(n^2) 

​	算法稳定性：稳定

- **折半插入排序**

**算法思路：**先⽤折半查找找到应该插⼊的位置，再移动元素。

**代码实现：**

```c++
//折半插入排序
void BInsertSort(int a[],int size){
    int i,j,low = 0,high = 0,mid;
    int temp = 0;
    for (i=1; i<size; i++) {
        low=0;
        high=i-1;
        temp=a[i];
        //采用折半查找法判断插入位置，最终变量 low 表示插入位置
        while (low<=high) {
            mid=(low+high)/2;
            if (a[mid]>temp) {
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        //有序表中插入位置后的元素统一后移
        for (j=i; j>low; j--) {
            a[j]=a[j-1];
        }
        a[low]=temp;//插入元素
    }
    print(a, 10, i);
}
```

```tex
输出：
1:2376584190
2:2376584190
3:2367584190
4:2356784190
5:2356784190
6:2345678190
7:1234567890
8:1234567890
9:0123456789
```

**算法效率分析：**

​	⽐起“直接插⼊排序”，⽐较关键字的次数减少了，但是移动元素的次数没变， 整体来看时间复杂度依然是O(n^2)。

### 2、希尔排序

希尔排序，又称“缩小增量排序”，也是插入排序的一种，但是同前面几种排序算法比较来看，希尔排序在时间效率上有很大的改进。

**算法思想：**先将整个记录表分割成若干部分，分别进行直接插入排序，然后再对整个记录表进行一次直接插入排序。

**示意图：**

<img src="D:\Files\VS-code\c and c++\Data Structure\Sort\img\希尔排序.png" alt="希尔排序" style="zoom:50%;" />

**代码实现：**

```c++
//希尔排序
void SheelSort(int *a,int n){
    int gap = n / 2;
    for (  ; gap>0; gap = gap / 2)
    {
        for (int i = gap; i <= n; i++)
        {
            int temp = a[i];
            int j;
            for (j = i-gap; j>=0&&temp<a[j]; j-=gap)
            {
                a[j + gap] = a[j];
            }
            a[j + gap] = temp;
        }
        print(a, 10, gap);
    }
}
```

```tex
输出：
5:3216084795
2:0215364798
1:0123456789
```

**算法效率分析：** 

​	时间复杂度：O(nlogn) 

​	时间复杂度：和增量序列 d1, d2, d3… 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度最坏时间复杂度为 O(n^2 )，当n在某个范围内时，可达O(n^1.3)

​	非稳定排序  

​	原地排序

### 3、冒泡排序

**算法思想：** 将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列。

**示意图：**

![冒泡排序](D:\Files\VS-code\c and c++\Data Structure\Sort\img\冒泡排序.gif)

**代码实现：**

```c++
//冒泡排序
void BubbleSort(int *a,int n){
    int count = 0;
    for (int i = 0; i < n-1; i++)
    {
        count = 0;
        for (int j = n-1; j > i; j--)
        {
            if(a[j-1]>a[j])
            {
                count = 1;
                swap(a[j-1], a[j]);
            }
        }
        if (count==0)
            break;

        print(a, 10, i);
    }
}
```

```tex
输出
0:0327658419
1:0132765849
2:0123476589
3:0123457689
4:0123456789
```

**算法效率分析:** 

​	空间复杂度：O(1)

​	最好时间复杂度（全部有序）：O(n) 

​	最坏时间复杂度（全部逆序）：O(n^2) 

​	平均时间复杂度：O(n^2) 

​	算法稳定性：稳定

### 4、快速排序

` 注：C语言中自带函数库中就有快速排序——qsort函数 ，包含在 <stdlib.h> 头文件中。`

**算法思想：**通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小，然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就成为了有序序列。

1.  先将 A[0]存至某个临时变量 temp，并令两个下标 left、right 分别指向序列首尾（如令left = 0、right = n)。
2. 只要 right 指向的元素 A[right]大于 temp,就将 right 不断左移;当某个时候 A[right]≤temp 时，将元素 A[right]挪到 left 指向的元素 A[left)处。
3. 只要left 指向的元素 A[left]不超过 temp,就将 left 不断右移;当某个时候 A[left]>temp时，将元素 A[left]挪到 right 指向的元素 A[right]处。
4. 重复2、3，直到left 与 right相遇，把 temp（也即原 A[1]）放到相遇的地方。

**示意图：**

![快速排序](D:\Files\VS-code\c and c++\Data Structure\Sort\img\快速排序.gif)

**代码实现：**

```c++
//对区间[left,right]进行划分
int Partition(int *a,int left,int right){
    int temp = a[left];
    while (left<right)
    {
        while (left<right && a[right]>temp)
            right--;
        a[left] = a[right];
        while (left<right && a[left]<=temp)
            left++;
        a[right] = a[left];
    }
    a[left] = temp;
    return left;
}

//快速排序
void QuickSort(int *a,int left,int right){
    if(left<right){
        int pos = Partition(a, left, right);
        QuickSort(a, left, pos - 1);
        QuickSort(a, pos + 1, right);
    }
}
```

```tex
输出：
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
```

**算法效率分析:** 

​	空间复杂度：最好：O(n)。最坏：O(log n)。

​	最好时间复杂度（每次划分很平均）：O(n log n) 

​	最坏时间复杂度（原本正序或逆序）：O(n^2) 

​	平均时间复杂度：O(n log n) 

​	算法稳定性：不稳定

### 5、简单选择排序

**示意图：**

![选择排序](D:\Files\VS-code\c and c++\Data Structure\Sort\img\选择排序.gif)

**代码实现：**

```c++
//简单选择排序
void SelectSort(int a[],int n){
    int temp;
    for(int i=0;i<n-1;i++){
        temp=i;      
        for(int j=i+1;j<n;j++){
            if(a[temp]>a[j]){   
                temp=j;  
            }
        }
        swap(a[i],a[temp]); 
        print(a, 10, i);
    }
} 
```

```
输出：
0:0276584193
1:0176584293
2:0126584793
3:0123584796
4:0123485796
5:0123458796
6:0123456798
7:0123456798
8:0123456789
```

**算法效率分析:** 

​	空间复杂度：O(1)

​	时间复杂度：O(n^2) 

​	算法稳定性：不稳定

### 6、堆排序

**堆的定义：** 

**示意图：**

![堆排序](D:\Files\VS-code\c and c++\Data Structure\Sort\img\堆排序.gif)

**代码实现：**

```c++

```

**算法效率分析:** 



### 7、归并排序

- **二路归并排序：**

示意图：

<img src="D:\Files\VS-code\c and c++\Data Structure\Sort\img\归并排序.gif" alt="归并排序" style="zoom: 200%;" />

代码实现：

```c++

```

**算法效率分析:** 



- **k路归并排序：**

代码实现：

```c++

```

**算法效率分析: ** 



### 8、基数排序

示意图：

<img src="D:\Files\VS-code\c and c++\Data Structure\Sort\img\基数排序.gif" alt="基数排序" style="zoom:60%;" />

代码实现：

```c++

```

**算法效率分析:** 



## 三、外部排序

### 1、多路平衡归并



### 2、败者树



### 3、置换-选择排序



### 4、最佳归并树

