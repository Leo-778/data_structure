# 贪心算法

## 一、什么是贪心算法

​		贪心法是求解一类**最优化问题**的方法，它总是考虑达到每一阶段下的**局部最优**，从而逐步达到**全局最优**。

​		举个例子：例如，有⼀堆钞票，你能拿10次，每次最多只会能拿5张，如果要使拿到的金额最多，要怎么拿？肯定是每次拿最大的，结果肯定是拿到的金额最多。每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。

## 二、什么时候用贪心

​		**贪心策略适用的前提是：局部最优策略能导致产生全局最优解。**

​		显然，如果采取较优而非最优的策略（最优策略可能不存在或是不易想到)，得到的全局结果也无法是最优的。而要获得最优结果，则要求中间的每步策略都是最优的，因此严谨使用贪心法来求解最优化问题需要对采取的策略进行证明。证明的一般思路是使用**反证法**及**数学归纳法**，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。

​		不过对平常使用来说，也许没有时间或不太容易对想到的策略进行严谨的证明（贪心的证明往往比贪心本身更难)，因此一般来说，如果在想到某个似乎可行的策略，并且自己无法举出反例，那么就勇敢地实现它。

## 三、贪心算法的基本思路	

贪⼼算法⼀般分为如下四步： 

1. 将问题分解为若⼲个⼦问题 
2. 找出适合的贪⼼策略 
3. 求解每⼀个⼦问题的最优解 
4. 将局部最优解堆叠成全局最优解

贪心算法没有具体的套路和框架，具体问题还是需要具体分析。

## 四、经典例题

### 1、最优装载问题

**描述：**

给定n个货物及船只的最大载重maxweight，每件货物重$W_i$（下标从0开始），求怎么能够装载最多数量的货物到船上呢？并给出货物重量

**示例：**

```
输入：
船只的最大载重maxweight=30
给定货物数量n=8
重量分别为：W={4, 10, 7, 11, 3, 5, 14, 2}

输出：
5
2 3 4 5 7
```

**分析：**

​		这个问题是一个典型的可以使用贪心算法解决的问题。

​		通过分析题目可以看到，小船的载重量（MAXWEIGHT）是固定的，要求装载的物品数量最多，那么应该每次都选择最轻的，然后再从剩下的n-1件物品中选择最轻的，直到达到小船载重量的要求。

​		选择先装载重量最小的物品，这个选择策略就采用了贪心（Greedy）策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。

​		算法策略：把n件物品 从小到大排序，然后根据贪心策略尽可能多的选出前i个物品，直到不能装为止。

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;
//最优装载问题

const int maxweight = 30;//船只的最大载重
const int n = 8;//货物数量
int cnt = 0,p[n];//数组p用来存放可以放入的货物的重量

void maxloading(int *w,int n){
    int sum = 0;
    for (int i = 0; i < n; i++)
    {
        if (sum+w[i]<maxweight)
        {
            sum += w[i];
            cnt++;
            p[i] = w[i];
        }
        else
            break;
    }
}
int main(int argc, char const *argv[])
{
    int w[n] = {4, 10, 7, 11, 3, 5, 14, 2};
    sort(w, w + 8);//排序（从w[0]到w[7]排序）
    maxloading(w, n);
    printf("%d\n", cnt);
    for (int i = 0; i < cnt; i++)
    {
        printf("%d ", p[i]);
    }
    return 0;
}
```

### 2、活动安排

**描述：**

​		设有N个活动时间集合，每个活动都要使用同一个资源，比如说会议场，而且同一时间内只能有一个活动使用，每个活动都有一个使用活动的开始start[i]和结束时间end[i]，即他的使用区间为（start[i],end[i]）,现在要求你分配活动占用时间表，即哪些活动占用该会议室，哪些不占用，使得他们不冲突，要求是尽可能多的使参加的活动最大化，即所占时间区间最大化！

| i        | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| start[i] | 1    | 3    | 0    | 5    | 3    | 5    | 6    | 8    | 8    | 2    | 12   |
| end[i]   | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |

上表为每个活动的开始和结束时间，我们的任务就是安排资源给活动使用 使活动的数量最大，及输出每个活动的时间段。

**示例：**

```
输入：
活动的数量n=11；
每个活动开始时间start[11]={1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
结束时间end[11]={4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
输出：
活动1 开始时间:1,结束时间:4
活动4 开始时间:5,结束时间:7
活动8 开始时间:8,结束时间:11
活动11 开始时间:12,结束时间:14
```

**思路：**

​		每个活i都有一个要求使用该资源的起始时间start[i]和一个结束时间end[i],且start[i] < end[i] 。如果选择了活动i，则它在半开时间区间[start[i], end[i])内占用资源。
​		若区间[start[i], end[i])与区间[start[j], end[j])不相交，则称活动i与活动j是相容的。也就是说，当start[i] >= end[j]或start[j] >= end[i]时，活动i与活动j相容。

​		算法策略是：每次总是选择具有最早完成时间的相容活动加入集合A中，

​		注：end数组已经是从小到大的了，题目简化了很多。

**代码实现：**

```c++
#include<stdio.h>

const int n = 11;
int used[n]={false};//数组used用来记录那个活动进行过

void greedySelector(int *start,int *end){
	used[0] = true;
	int j = 0;
	for (int i = 1; i < n; i++)
	{
		if (start[i]>end[j])//相容
		{
			used[i] = true;//标记使用
			j = i;
		}
	}
}

int main(int argc, char const *argv[])
{
	int start[11]={1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
	int end[11]={4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
	greedySelector(start, end);
	for (int i = 0; i < n; i++)
	{
		if (used[i]==true)
		{
			printf("活动 %d ", i+1);
			printf("开始时间：%d ;结束时间：%d \n", start[i], end[i]);
		}
		
	}
	return 0;
}
```

### 3、跳跃游戏

**描述：**

给定⼀个⾮负整数数组，你最初位于数组的第⼀个位置。 数组中的每个元素代表你在该位置可以跳跃的最⼤⻓度。 判断你是否能够到达最后⼀个位置。

**示例：**

```
示例 1:
输⼊: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后⼀个位置。
示例 2:
输⼊: [3,2,1,0,4]
输出: false
解释: ⽆论怎样，你总会到达索引为 3 的位置。但该位置的最⼤跳跃⻓度是 0 ， 所以你永远不可能到达最后⼀个位置。
```

**思路：**

这道题比较简单，算法策略是：每次移动取最⼤跳跃步数（得到最⼤的覆盖范围），每移动⼀个单位，就更新最⼤覆盖范围maxreach。只要maxreach大于等于n-1就可以返回true，当i大于maxreach就返回false。

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;

const int N = 5;

bool canJump(int *a){
    int maxreach = 0; //注意是下标值，而不是元素值
    for(int i = 0; i !=N;i++)
    {
        if(i > maxreach) //注意false的条件，就是maxreach停止了，而i仍然在增加，一直到超过maxreach也没有停止，对应题目中的反例很好理解
            return false;
        maxreach = max(maxreach, i + a[i]);  //maxreach 表示当前第i个位置最远可以到达的位置
        if (maxreach >= N-1)  //一个小细节，要写成>=而不是写成==
            return true;
    }
    return false;
}

int main(int argc, char const *argv[])
{
    int p[5] = {3,2,1,1,4};
    printf("%d",canJump(p));
    return 0;
}
```

### 4、跳跃游戏Ⅱ

**描述：**

给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

**示例：**

```
示例:
输⼊: [2,3,1,1,4]
输出: 2
解释: 跳到最后⼀个位置的最⼩跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最
后⼀个位置。
说明:
假设你总是可以到达数组的最后⼀个位置。

示例：
输入: [2,3,0,1,4]
输出: 2
解释: 跳到最后⼀个位置的最⼩跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最
后⼀个位置。
```

**思路：**

也是利用贪心的思想，从下标0开始，找到从下标0出发最远可以到达的位置中，可以达到更远位置的下标，例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3 最大，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。

继续从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。以此类推。

在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。

在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;

int n = 5;

int jump(int *nums){
    int maxpos = 0;// 目前能跳到的最远位置
    int step = 0;//步数
    int end = 0; // 上次跳跃可达范围右边界（下次的最右起跳点）
    for (int i = 0; i < n-1; i++)
    {
            if(maxpos >=i ){
                maxpos = max(maxpos, i + nums[i]);
                //（if里面的内容是用来判断什么时候步数需要++，只有当i等于上次起跳的最远范围时才++，可以自己运行调试理解）
                if (i==end)
                {
                    end = maxpos;// 目前能跳到的最远位置变成了下次起跳位置的右边界
                    ++step;// 进入下一次跳跃
                }
            }
    }
    return step;
}
int main(int argc, char const *argv[])
{
    int nums[n] = {2,3,1,1,4};
    printf("%d", jump(nums));
    return 0;
}
```

### 5、⽆重叠区间

**描述：**

​		给定⼀个区间的集合，找到需要移除区间的最⼩数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是⼤于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例：**

```
示例 1:
输⼊: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:
输⼊: [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:
输⼊: [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是⽆重叠的了。
```

**思路：**

这道题类似于上面第二道题：活动安排，只不过者这里用的是二维数组，并且是没有排序的。

因此首先先对二维数组右边部分进行排序，例如：[ [1,**2**], [2,**3**], [3,**4**], [1,**5**] ] 排序后为[ [1,**2**], [2,**3**], [3,**4**], [1,**5**] ]，之后就和活动安排是一样的了，只需要加一个int 型变量 count 用来计数，count 计的是相容的数，因此需要拿n减去。

**代码实现：**

```c++
#include<stdio.h>
#include<vector>
#include<algorithm>
using namespace std;
//无重叠区域
int n = 4;

// 按照区间右边界排序
bool cmp (const vector<int>& a, const vector<int>& b) {
    return a[1] < b[1];
}

int eraseOverlapIntervals1(vector<vector<int> > intervals){
    if(intervals.empty())// 如果长度为0则返回0
        return 0;

    sort(intervals.begin(), intervals.end(), cmp);// 按照首元素进行升序排序
    int n = intervals.size();
    int ans = 1;
    int j = 0;
    for (int i = 1; i < n; i++)
    {
        if (intervals[i][0]>=intervals[j][1])
        {
            ans++;
            j = i;
        }
    }
    return n - ans;
}


int main(int argc, char const *argv[])
{
    vector<vector<int>> intervals = {{1,100}, {11,22}, {1,11}, {2,12}};
    
    printf("%d", eraseOverlapIntervals1(intervals));
    return 0;
}

```

