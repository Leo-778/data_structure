# 贪心算法

## 一、什么是贪心算法

​		贪心法是求解一类**最优化问题**的方法，它总是考虑达到每一阶段下的**局部最优**，从而逐步达到**全局最优**。

​		举个例子：例如，有⼀堆钞票，你能拿10次，每次最多只会能拿5张，如果要使拿到的金额最多，要怎么拿？肯定是每次拿最大的，结果肯定是拿到的金额最多。每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。

## 二、什么时候用贪心

​		**贪心策略适用的前提是：局部最优策略能导致产生全局最优解。**

​		显然，如果采取较优而非最优的策略（最优策略可能不存在或是不易想到)，得到的全局结果也无法是最优的。而要获得最优结果，则要求中间的每步策略都是最优的，因此严谨使用贪心法来求解最优化问题需要对采取的策略进行证明。证明的一般思路是使用**反证法**及**数学归纳法**，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。

​		不过对平常使用来说，也许没有时间或不太容易对想到的策略进行严谨的证明（贪心的证明往往比贪心本身更难)，因此一般来说，如果在想到某个似乎可行的策略，并且自己无法举出反例，那么就勇敢地实现它。

## 三、贪心算法的基本思路	

贪⼼算法⼀般分为如下四步： 

1. 将问题分解为若⼲个⼦问题 
2. 找出适合的贪⼼策略 
3. 求解每⼀个⼦问题的最优解 
4. 将局部最优解堆叠成全局最优解

贪心算法没有具体的套路和框架，具体问题还是需要具体分析。

## 四、经典例题

### 1、最优装载问题

**描述：**

给定n个货物及船只的最大载重maxweight，每件货物重$W_i$（下标从0开始），求怎么能够装载最多数量的货物到船上呢？并给出货物重量

**示例：**

```
输入：
船只的最大载重maxweight=30
给定货物数量n=8
重量分别为：W={4, 10, 7, 11, 3, 5, 14, 2}

输出：
5
2 3 4 5 7
```

**分析：**

​		这个问题是一个典型的可以使用贪心算法解决的问题。

​		通过分析题目可以看到，小船的载重量（MAXWEIGHT）是固定的，要求装载的物品数量最多，那么应该每次都选择最轻的，然后再从剩下的n-1件物品中选择最轻的，直到达到小船载重量的要求。

​		选择先装载重量最小的物品，这个选择策略就采用了贪心（Greedy）策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。

​		算法策略：把n件物品 从小到大排序，然后根据贪心策略尽可能多的选出前i个物品，直到不能装为止。

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
ustart[i]ng namespace std;
//最优装载问题

const int maxweight = 30;//船只的最大载重
const int n = 8;//货物数量
int cnt = 0,p[n];//数组p用来存放可以放入的货物的重量

void maxloading(int *w,int n){
    int sum = 0;
    for (int i = 0; i < n; i++)
    {
        if (sum+w[i]<maxweight)
        {
            sum += w[i];
            cnt++;
            p[i] = w[i];
        }
        else
            break;
    }
}
int main(int argc, char const *argv[])
{
    int w[n] = {4, 10, 7, 11, 3, 5, 14, 2};
    sort(w, w + 8);//排序（从w[0]到w[7]排序）
    maxloading(w, n);
    printf("%d\n", cnt);
    for (int i = 0; i < cnt; i++)
    {
        printf("%d ", p[i]);
    }
    return 0;
}
```

### 2、活动安排

**描述：**

​		设有N个活动时间集合，每个活动都要使用同一个资源，比如说会议场，而且同一时间内只能有一个活动使用，每个活动都有一个使用活动的开始start[i]和结束时间end[i]，即他的使用区间为（start[i],end[i]）,现在要求你分配活动占用时间表，即哪些活动占用该会议室，哪些不占用，使得他们不冲突，要求是尽可能多的使参加的活动最大化，即所占时间区间最大化！

| i        | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| start[i] | 1    | 3    | 0    | 5    | 3    | 5    | 6    | 8    | 8    | 2    | 12   |
| end[i]   | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |

上表为每个活动的开始和结束时间，我们的任务就是安排资源给活动使用 使活动的数量最大，及输出每个活动的时间段。

**示例：**

```
输入：
活动的额数量n=11；
每个活动开始时间start[11]={1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
结束时间end[11]={4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
输出：
活动1 开始时间:1,结束时间:4
活动4 开始时间:5,结束时间:7
活动8 开始时间:8,结束时间:11
活动11 开始时间:12,结束时间:14
```

**思路：**

​		每个活i都有一个要求使用该资源的起始时间start[i]和一个结束时间end[i],且start[i] < end[i] 。如果选择了活动i，则它在半开时间区间[start[i], end[i])内占用资源。
​		若区间[start[i], end[i])与区间[start[j], end[j])不相交，则称活动i与活动j是相容的。也就是说，当start[i] >= end[j]或start[j] >= end[i]时，活动i与活动j相容。

​		算法策略是：每次总是选择具有最早完成时间的相容活动加入集合A中，

​		注：end数组已经是从小到大的了，题目简化了很多。

**代码实现：**

```c++
#include<stdio.h>

const int n = 11;
int used[n]={false};//数组used用来记录那个活动进行过

void greedySelector(int *start,int *end){
	used[0] = true;
	int j = 0;
	for (int i = 1; i < n; i++)
	{
		if (start[i]>end[j])//相容
		{
			used[i] = true;//标记使用
			j = i;
		}
	}
}

int main(int argc, char const *argv[])
{
	int start[11]={1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
	int end[11]={4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
	greedySelector(start, end);
	for (int i = 0; i < n; i++)
	{
		if (used[i]==true)
		{
			printf("活动 %d ", i+1);
			printf("开始时间：%d ;结束时间：%d \n", start[i], end[i]);
		}
		
	}
	return 0;
}
```

### 3、跳跃游戏

**描述：**

给定⼀个⾮负整数数组，你最初位于数组的第⼀个位置。 数组中的每个元素代表你在该位置可以跳跃的最⼤⻓度。 判断你是否能够到达最后⼀个位置。

**示例：**

```
示例 1:
输⼊: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后⼀个位置。
示例 2:
输⼊: [3,2,1,0,4]
输出: false
解释: ⽆论怎样，你总会到达索引为 3 的位置。但该位置的最⼤跳跃⻓度是 0 ， 所以你永远不可能到达最后⼀个位置。
```

**思路：**

这道题比较简单，算法策略是：每次移动取最⼤跳跃步数（得到最⼤的覆盖范围），每移动⼀个单位，就更新最⼤覆盖范围maxreach。只要maxreach大于等于n-1就可以返回true，当i大于maxreach就返回false。

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;

const int N = 5;

bool canJump(int *a){
    int maxreach = 0; //注意是下标值，而不是元素值
    for(int i = 0; i !=N;i++)
    {
        if(i > maxreach) //注意false的条件，就是maxreach停止了，而i仍然在增加，一直到超过maxreach也没有停止，对应题目中的反例很好理解
            return false;
        maxreach = max(maxreach, i + a[i]);  //maxreach 表示当前第i个位置最远可以到达的位置
        if (maxreach >= N-1)  //一个小细节，要写成>=而不是写成==
            return true;
    }
    return false;
}

int main(int argc, char const *argv[])
{
    int p[5] = {3,2,1,1,4};
    printf("%d",canJump(p));
    return 0;
}
```

### 4、跳跃游戏Ⅱ

**描述：**

给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

**示例：**

```
示例:
输⼊: [2,3,1,1,4]
输出: 2
解释: 跳到最后⼀个位置的最⼩跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最
后⼀个位置。
说明:
假设你总是可以到达数组的最后⼀个位置。

示例：
输入: [2,3,0,1,4]
输出: 2
解释: 跳到最后⼀个位置的最⼩跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最
后⼀个位置。
```

**思路：**

方法一：

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;

int n = 5;

int jump(int *nums){
    int maxcover = 0;//当前覆盖最远距离的下标
    int step = 0;//步数
    int nextcover = 0;//下一步覆盖最远距离的下标
    for (int i = 0; i < n; i++)
    {
        nextcover = max(nums[i] + i, nextcover);//更新下⼀步覆盖最远距离下标
        if (i==maxcover)// 遇到当前覆盖最远距离下标
        {
            if (maxcover!=n-1)// 如果当前覆盖最远距离下标不是终点
            {
                step++;// 需要⾛下⼀步
                maxcover = nextcover;// 更新当前覆盖最远距离下标
                if (nextcover>=n-1)
                {
                    break;// 下⼀步的覆盖范围已经可以达到终点，结束循环
                }
            }
            else break; 
        }
        
    }
    return step;
}
int main(int argc, char const *argv[])
{
    int nums[n] = {2,3,1,1,4};
    printf("%d", jump(nums));
    return 0;
}
```



### 5、



