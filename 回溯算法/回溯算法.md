# 回溯算法

## 一、什么是回溯法

​	在程序设计中，有一类求一组解、或求全部解或求最优解的问题，如最熟悉的n皇后、全排列问题等。不是根据某种确定的计算法则，而是利用试探和**回溯**的搜索技术求解。回溯法也是设计递归过程的一种重要方法,它的求解过程==实质上是一个先序遍历一棵“状态树”的过程==,只是这棵树不是遍历前预先建立的,而是隐含在遍历过程中,但如果认识到这点,很多问题的递归过程设计也就迎刃而解了，回溯法**通常用最简单的递归方法来实现**。下图为在解决 n=3全排列问题构造的状态树。

<img src="D:\Files\VS-code\c and c++\Data Structure\回溯算法\img\全排列.png" alt="全排列" style="zoom:67%;" />

## 二、回溯法解决的问题

在包含问题的所有解的解空间树中，按照**深度优先搜索的策略**，从根结点出发深度探索解空间树。

回溯法，⼀般可以解决如下⼏种问题：

- 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合 

- 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式 

- ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集 

- 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式 

- 棋盘问题：N皇后，解数独等等

  为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，因此回溯适合于一些需要穷举的问题。另外，由于需要穷举，回溯算法的效率不高。

## 三、回溯算法的基本思想

​	对于用回溯法求解的问题，首先要将问题进行适当的转化，得出==状态树==。这棵树的每条完整路径都代表了一种解的可能。通过==深度优先==搜索这棵树，枚举每种可能的解的情况；从而得出结果。但是，回溯法中通过构造约束函数，可以大大提升程序效率，因为在深度优先搜索的过程中，不断的将每个解（并不一定是完整的，事实上这也就是构造约束函数的意义所在）与约束函数进行对照从而删除一些不可能的解，这样就不必继续把解的剩余部分列出从而节省部分时间。

回溯法中，首先需要明确下面三个概念：

1. **约束函数**：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。
2. **状态树**：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。
3. **扩展节点、活结点、死结点**：所谓扩展节点，就是当前正在搜索它的子节点的节点。活结点就是一个自身已搜索但其子节点还没有被全部搜索的结点；死结点就是所有儿子节点已经全被搜索。

​	回溯法从开始节点出发，以深度优先方式搜索解空间树，开始结点成为活结点，也成为当前的扩展结点。在当前扩展结点处，向纵深方向移到一个新结点，这个新结点成为新的活结点，并成为当前扩展结点，如果在当前扩展结点处不能再向纵深方向移动，则当前扩展节点就成为死节点，此时应向回移动(回溯)至最近的活结点，并使这个活结点成为当前扩展节点。继续这个搜索过程，直到找到所要求的解或解空间中已无活节点为止。所以回溯法体现出走不通就退回再走的思路。

## 四、用回溯法解题的一般步骤

首先，要通过读题完成下面三个步骤：

​	(1)描述解的形式，定义一个解空间，它包含问题的所有解，这一步主要明确问题的解空间树。

​	(2)构造状态空间树。

​	(3)构造约束函数（用于杀死节点）。

然后就开始遍历，回溯法⼀般是在集合中递归搜索，集合的⼤⼩构成了树的宽度，递归的深度构成的树的深度。

<img src="D:\Files\VS-code\c and c++\Data Structure\回溯算法\img\回溯遍历.png" alt="回溯遍历" style="zoom: 67%;" />

遍历过程伪代码如下：

```c++
for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
 处理节点;
 backtracking(); // 递归
 回溯，撤销处理结果
}
```

for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，⼀般来说，搜索叶⼦节点就是找的其中⼀个结果了。

回溯算法框架如下：

```c++
void backtracking(参数) {
	if (终⽌条件) {
 		存放结果;
		return;
	}
	for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
 	 	处理节点;
	 	backtracking(); // 递归
 	 	回溯，撤销处理结果
     }
}
```

## 五、典型题目应用

### 1 全排列问题

**描述：**

​	一般把 1 ～n 这 n 个整数按某个顺序摆放的结果称为这 n 个整数的一个排列，而全排列指这 n 个整数能形成的所有排列。例如对 1、2、3 这三个整数来说，(1, 2, 3)、(1, 3, 2)、(2, 1, 3)、(2, 3, 1)、(3, 1, 2)、(3,2, 1)就是 1～3 的全排列。

​	现在需要实现按字典序从小到大的顺序输出1~n 的全排列,其中(a1, a2,…,an)的字典序小于(b1,b2,…, ba)是指存在一个 i，使得 a1=b1、a2= b2、…、ai-1=bi-1、ai<bi成立。因此上面 n =3的例子就是按字典序从小到大的顺序给出的。

 **示例 ：**

```c++
输入：
n = 3
输出：
[[1,2,3], 
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]]
```

**思路：**

​	设定一个数组 P，用来存放当前的排列；再设定一个数组used，其中 used[x]当整数 × 已经在数组 P中时为 true。现在按顺序往 P 的第 1 位到第 n 位中填入数字。不妨假设当前已经填好了 P[1]～P[index-1]，正准备填 P[index]。显然需要枚举 1～n，如果当前枚举的数字 x还没有在 P[1]～P[index- 1]中（即 used[x] = false)，那么就把它填入 P[index]，同时将 used[x]置为 true，然后去处理 P 的第 index +1 位(即进行递归);而当递归完成时,再将used[x]还原为 false,以便让 P[index]填下一个数字。

<img src="D:\Files\VS-code\c and c++\Data Structure\回溯算法\img\全排列状态树.png" alt="全排列状态树" style="zoom:67%;" />

**代码实现：**

```c++
#include<stdio.h>

const int maxn = 11;

//P为当前排列，used记录整数x是否已经在P中
int n, P[maxn], used[maxn] = {false};

//当前处理排列的第index位
void generate(int index){
    if (index == n+1)//递归边界，已经处理完排列的1~n位
    {
        for (int i = 1; i <= n; i++)
        {
            printf("%d", P[i]);
        }
        printf("\n");
        return;
    }
    for (int x = 1; x <= n; x++) //枚举1~n，试图将x填入P[index];
    {
        if (used[x]==false)//如果x不在P[0]~P[index-1]中
        {
            P[index] = x;//令P的第index位为x，即把x加入当前排列
            used[x] = true;//记x已经在P中
            generate(index + 1);//处理排列的第inde+1号位（递归）
            used[x] = false;//已处理完P[index]为x的子问题（回溯，撤销标记）
        }
    }
}

int main(int argc, char const *argv[])
{
    n = 3;
    generate(1);
    return 0;
}
```

**复杂度分析：**

- 时间复杂度

回溯算法的时间复杂度主要由递归树的个数决定，而在全排列中，程序在叶子结点和非叶子结点的行为是不一样的，因此需要分开计算。

非叶子结点：

![全排列非叶结点](D:\Files\VS-code\c and c++\img\全排列非叶结点.png)

将2视为常系数1，每个内部节点循环n次，故非叶子结点的时间复杂度为O（n x n！）

叶子结点：

​	就是n！，在叶子结点需要做循环输出，需要O（n），叶子结点的时间复杂度也为O（n x n!）

总的时间复杂度为：O（n x n！）

- 空间复杂度

  O（n x n！），n为数组长度。

### 2、n皇后问题

**描述：**

​	n 皇后问题是指在一个 n*n 的国际象棋棋盘上放置 n 个皇后，使得这 n 个皇后两两均不在同一行、同一列、同一条对角线上，求合法的方案数。例如下图是n=5 的情况，其中图 a 是一个合法的方案，而图  b 由于有两个皇后在同一条对角线，因此不是合法方案。

<img src="D:\Files\VS-code\c and c++\Data Structure\回溯算法\img\n皇后.jpg" alt="n皇后" style="zoom:13%;" />

**示例（已4皇后为例）：**

```out
输出：
* Q * *
* * * Q
Q * * *
* * Q *

* * Q *
Q * * *
* * * Q
* Q * *

摆放的方式有 2 种
```

**思路：**

n皇后的约束条件：

1. 不能同⾏ 
2. 不能同列  
3. 不能同斜线

下面是n=4时，构造的部分状态树：

<img src="D:\Files\VS-code\c and c++\Data Structure\回溯算法\img\n皇后状态树.png" alt="n皇后状态树" style="zoom:75%;" />

​	一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要当前列是否合法，如果合法，则将皇后放置在当前位置，并进行递归，回溯。每行都摆满皇后时，则产生了一种解法，将所有解法收集并返回。

判断合法时，只需要判断列、45度、135度即可，

**代码实现：**

```c++
#include<stdio.h>
int n=4;
int count = 0;
bool isvalid(int row,int col,char Q[4][4]){//检查位置是否合法
    //检查列
    for (int i = 0; i < row; i++)
    {
        if(Q[i][col]=='Q')
            return false;
    }
    //检查45度
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--)
    {
        if(Q[i][j]=='Q')
            return false;
    }
    //检查135度
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)
    {
        if(Q[i][j]=='Q')
            return false;
    }
    return true;
}
void Queue(int row,char Q[4][4]){
    if (row==4)
    {
        for(int i=0; i<4; i++){
            for(int k=0; k<4; k++)
                printf("%c ", Q[i][k]);//得到一个解，在屏幕上显示
            printf("\n");
        }
        printf("\n");
        count++;
        return ;
    }
    for (int i = 0; i < 4; i++)
    {
        if (isvalid(row,i,Q))
        {
            Q[row][i] = 'Q';//放置皇后
            Queue(row + 1, Q);
            Q[row][i] = '*';
        }
        
    }
    
}
int main()
{
    char Q[4][4];
    for(int i=0; i<4; i++)
        for(int j=0; j<4; j++)
            Q[i][j] = '*';
    Queue(0, Q);
    printf("摆放的方式有 %d 种\n", count);
    return 0;
}
```

### 3、组合

**描述：**

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例：**

```out
输入: 
n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**思路：**

把组合问题的解的过程

![组合状态树](D:\Files\VS-code\c and c++\Data Structure\回溯算法\img\组合状态树.png)



### 4、分割回文串

**描述：**

​	给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

​	回文串 是正着读和反着读都一样的字符串。

**示例：**

```
1、
输入：
s = "aab"
输出：
[["a","a","b"],
["aa","b"]]

2、
输入：
s = "a"
输出：
[["a"]]
```

**思路：**

