# 查找

查找表是由同一类型的数据元素构成的集合。

一般对于查找表有以下几种操作：

- 在查找表中查找某个具体的数据元素；
- 在查找表中插入数据元素；
- 从查找表中删除数据元素；

在查找表中只做查找操作，而不改动表中数据元素，称此类查找表为静态查找表；

在查找表中做查找操作的同时进行插入数据或者删除数据的操作，称此类表为动态查找表。

## 一、静态查找表

###  1、顺序查找

#### 1.1  一般线性表的顺序查找

​	查找过程：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。

**代码实现：** 

```c++
//顺序查找
int Search_Seq(SSTable ST, int key){
    for (int i = 0; i < ST.len; i++)
    {
        if (ST.elem[i]==key)
        {
            return i;
        }
    }
    return -1;
}
```

或者：

```c++
//顺序查找（带哨兵）
int Search_Seq(SSTable ST, int key){
    ST.elem[0]=key;
    for(int i=St.len;St.elem[i] != key; i--);
    return i;//若表中不存在关键字为key的元素，将查找到i为0时退出for循环。
}
```

`在上述算法中,将 ST.elem[0]称为“哨兵”。引入它的目的是使得 Search_Seq 内的循环不必判断数组是否会越界，因为满足 i==0 时，循环一定会跳出。需要说明的是，在程序中引入“哨兵”并不是这个算法独有的。引入“哨兵”可以避免很多不必要的判断语句，从而提高程序效率。`

**性能分析：** 

​	整个查找过程其实大部分时间花费在关键字和查找表中的数据进行比较上。时间复杂度为：O（n）

​	衡量查找算法好坏的依据：查找成功时，查找的关键字和查找表中的数据元素中进行过比较的个数的平均值，称为平均查找长度（Average Search Length，用 ASL 表示）。

​	对于具有 n 个数据元素的查找表，查找成功的平均查找长度的计算公式为：
$$
ASL_{成功} = \sum _{i=1} ^ {n} P_i(n-i+1)
$$
​	当在含有 n 个数据元素的查找表中，各数据被查找的概率是相同时，即 Pi = 1 / n 时，有：
$$
ASL_{成功} = \sum _ {i=1}^{n} P_i(n-i+1)=\frac{n+1}{2}
$$
​	查找不成功时，各个关键字对比次数为 n + 1 次，故：
$$
ASL_{失败} = n +1
$$

#### 1.2 有序表的顺序查找

​	若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\顺序查找判定树.png" alt="顺序查找判定树" style="zoom: 67%;" />

**代码实现：**

```c++
//有序表顺序查找
int Search_Seq(SSTable ST, int key){
    for (int i = 0; i < ST.len; i++)
    {
        if (ST.elem[i]==key)
        {
            return i;
        }
        if(ST.elem[i+1]>key){
            break;
        }
    }
    return -1;
}
```

**性能分析：** 

​	时间复杂度为：O（n）

​	在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为：
$$
ASL_{失败} = \sum _{j=1}^{n}P_j(l_j-1)=\frac{1+2+3+...+n+n}{n+1}= \frac{n}{2} + \frac{n}{n+1}
$$
在概率相等时： P j = 1 / (n+1) ，l j 是 j 所在层数。

### 2、折半查找

#### 	2.1 折半查找

​	**折半查找**，也称二分查找，在某些情况下相比于顺序查找，折半查找有着更高的效率。但是该算法的使用的前提是静态查找表中的数据必须是有序的。

示意图：

![折半查找](D:\Files\VS-code\c and c++\Data Structure\Search\img\折半查找.gif)

**代码实现：** 

```c++
//排序
void sort(SSTable t){
    ...
}
//折半查找
int Binary_Search(SSTable t,int key){
    int low = 0, high = t.len - 1, mid;
    while(low<=high){
        mid = (low + high) / 2;
        if (t.elem[mid]==key)
        {
            return mid;
        }
        if (t.elem[mid]<key)
        {
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
    }
    return -1;
}
```

**查找效率分析：** 

​	折半查找的过程可以用==二叉树==来描述，成为==判定树==。显然判定树是一颗==平衡二叉树==。

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\折半查找判定树.png" alt="折半查找判定树" style="zoom:50%;" />

​	由上可知，用折半查找 查找到给定值的比较次数不会超过树的高度。等概率下，查找成功的平均查找长度为：
$$
ASL=\frac{1}{n} \sum_{i=1}^{n}l_i=\frac{1}{n}(1 \times 2 +2 \times 2+...+h \times 2^{h-1})=\frac{n+1}{n}log_2(n-1)-1 \approx log_2(n+1)-1
$$
​	式中 h 为树高。时间复杂度为O（log n）。

#### 	2.2 折半查找判定树的构造

过程如图：

![构造1](D:\Files\VS-code\c and c++\Data Structure\Search\img\构造1.png)

![构造2](D:\Files\VS-code\c and c++\Data Structure\Search\img\构造2.png)

![构造3](D:\Files\VS-code\c and c++\Data Structure\Search\img\构造3.png)

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\构造4.png" alt="构造4" style="zoom:105%;" />

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\构造5.png" alt="构造5" style="zoom:100%;" />

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\构造6.png" alt="构造6" style="zoom:90%;" />



**特性：**

- 判定树结点关键字：左<中<右，满⾜⼆叉排序树的定义
- 只有最下⾯⼀层是不满的，树⾼h = ⌈log2(n + 1)⌉
- 失败结点：n+1个（等于成功结点的空链域数量）
- 若 mid = ⌊(low + high)/2⌋，则对于任何⼀个结点，必有： ==右⼦树结点数-左⼦树结点数=0或1==

### 3、分块查找（很少考代码）

​	**分块查找**，也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表。例如下图，给定一个查找表，其对应的索引表如图所示：

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\分块查找.png" alt="分块查找" style="zoom:80%;" />

特点：块内⽆序、块间有序

**查找过程：**

 	①在索引表中确定待查记录所属的分块（可顺序、可折半）

​	 ②在块内顺序查找

**查找效率分析：** 

ASL = 查索引表的平均查找长度 + 查分块的平均查找长度

![分块查找ASL1](D:\Files\VS-code\c and c++\Data Structure\Search\img\分块查找ASL1.png)

![分块查找ASL2](D:\Files\VS-code\c and c++\Data Structure\Search\img\分块查找ASL2.png)

## 二、动态查找表

### 1、B树

#### 1.1 什么是B树

下图为一颗5阶B树：

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\B树.png" alt="B树" style="zoom: 67%;" />

m阶B树的特性： 

​	1）树中每个结点⾄多有m棵⼦树，即⾄多含有m-1个关键字。 

​	2）若根结点不是终端结点，则⾄少有两棵⼦树。 

​	3）除根结点外的所有⾮叶结点⾄少有 ⌈m/2⌉ 棵⼦树，即⾄少含有 ⌈m/2⌉-1个关键字。

​	4）所有⾮叶结点的结构如下： 

​	![非叶节点结构](D:\Files\VS-code\c and c++\Data Structure\Search\img\非叶节点结构.png)

​	其中，Ki（i = 1, 2,…, n）为结点的关键字，且满⾜==K1 < K2 <…< Kn==；Pi（i = 0, 1,…, n）为指向⼦树根结点 的指针，且指针==Pi-1所指⼦树中所有结点的关键字均⼩于Ki==，==Pi所指⼦树中所有结点的关键字均⼤于Ki==，n （⌈m/2⌉- 1≤n≤m - 1）为结点中关键字的个数。 

​	5）所有的叶结点都出现在同⼀层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失 败结点，实际上这些结点不存在，指向这些结点的指针为空）。

![B树树高](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树树高.png)

**1.2 B树的插入和删除**

**插入：** 



**删除：** 



### 2、B+树



## 三、哈希表（散列技术）

