# 查找

查找表是由同一类型的数据元素构成的集合。

一般对于查找表有以下几种操作：

- 在查找表中查找某个具体的数据元素；
- 在查找表中插入数据元素；
- 从查找表中删除数据元素；

在查找表中只做查找操作，而不改动表中数据元素，称此类查找表为静态查找表；

在查找表中做查找操作的同时进行插入数据或者删除数据的操作，称此类表为动态查找表。

## 一、静态查找表

###  1、顺序查找

#### 1.1  一般线性表的顺序查找

​	查找过程：从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。

**代码实现：** 

```c++
//顺序查找
int Search_Seq(SSTable ST, int key){
    for (int i = 0; i < ST.len; i++)
    {
        if (ST.elem[i]==key)
        {
            return i;
        }
    }
    return -1;
}
```

或者：

```c++
//顺序查找（带哨兵）
int Search_Seq(SSTable ST, int key){
    ST.elem[0]=key;
    for(int i=St.len;St.elem[i] != key; i--);
    return i;//若表中不存在关键字为key的元素，将查找到i为0时退出for循环。
}
```

`在上述算法中,将 ST.elem[0]称为“哨兵”。引入它的目的是使得 Search_Seq 内的循环不必判断数组是否会越界，因为满足 i==0 时，循环一定会跳出。需要说明的是，在程序中引入“哨兵”并不是这个算法独有的。引入“哨兵”可以避免很多不必要的判断语句，从而提高程序效率。`

**性能分析：** 

​	整个查找过程其实大部分时间花费在关键字和查找表中的数据进行比较上。时间复杂度为：O（n）

​	衡量查找算法好坏的依据：查找成功时，查找的关键字和查找表中的数据元素中进行过比较的个数的平均值，称为平均查找长度（Average Search Length，用 ASL 表示）。

​	对于具有 n 个数据元素的查找表，查找成功的平均查找长度的计算公式为：
$$
ASL_{成功} = \sum _{i=1} ^ {n} P_i(n-i+1)
$$
​	当在含有 n 个数据元素的查找表中，各数据被查找的概率是相同时，即 Pi = 1 / n 时，有：
$$
ASL_{成功} = \sum _ {i=1}^{n} P_i(n-i+1)=\frac{n+1}{2}
$$
​	查找不成功时，各个关键字对比次数为 n + 1 次，故：
$$
ASL_{失败} = n +1
$$

#### 1.2 有序表的顺序查找

​	若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\顺序查找判定树.png" alt="顺序查找判定树" style="zoom: 67%;" />

**代码实现：**

```c++
//有序表顺序查找
int Search_Seq(SSTable ST, int key){
    for (int i = 0; i < ST.len; i++)
    {
        if (ST.elem[i]==key)
        {
            return i;
        }
        if(ST.elem[i+1]>key){
            break;
        }
    }
    return -1;
}
```

**性能分析：** 

​	时间复杂度为：O（n）

​	在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为：
$$
ASL_{失败} = \sum _{j=1}^{n}P_j(l_j-1)=\frac{1+2+3+...+n+n}{n+1}= \frac{n}{2} + \frac{n}{n+1}
$$
在概率相等时： P j = 1 / (n+1) ，l j 是 j 所在层数。

### 2、折半查找

#### 	2.1 折半查找

​	**折半查找**，也称二分查找，在某些情况下相比于顺序查找，折半查找有着更高的效率。但是该算法的使用的前提是静态查找表中的数据必须是有序的。

示意图：

![折半查找](D:\Files\VS-code\c and c++\Data Structure\Search\img\折半查找.gif)

**代码实现：** 

```c++
//排序
void sort(SSTable t){
    ...
}
//折半查找
int Binary_Search(SSTable t,int key){
    int low = 0, high = t.len - 1, mid;
    while(low<=high){
        mid = (low + high) / 2;
        if (t.elem[mid]==key)
        {
            return mid;
        }
        if (t.elem[mid]<key)
        {
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
    }
    return -1;
}
```

**查找效率分析：** 

​	折半查找的过程可以用==二叉树==来描述，成为==判定树==。显然判定树是一颗==平衡二叉树==。

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\折半查找判定树.png" alt="折半查找判定树" style="zoom:50%;" />

​	由上可知，用折半查找 查找到给定值的比较次数不会超过树的高度。等概率下，查找成功的平均查找长度为：
$$
ASL=\frac{1}{n} \sum_{i=1}^{n}l_i=\frac{1}{n}(1 \times 2 +2 \times 2+...+h \times 2^{h-1})=\frac{n+1}{n}log_2(n-1)-1 \approx log_2(n+1)-1
$$
​	式中 h 为树高。时间复杂度为O（log n）。

#### 	2.2 折半查找判定树的构造

过程如图：

mid = ⌊(low + high)/2⌋

![构造1](D:\Files\VS-code\c and c++\Data Structure\Search\img\构造1.png)

如果当前low和high之间有==奇数个==元素，则 mid 分隔后，==左右==两部分元素个数==相等==

如果当前low和high之间有==偶数个==元素，则 mid 分隔后，==左==半部分==⽐右==半部分==少==⼀个==元素

![构造2](D:\Files\VS-code\c and c++\Data Structure\Search\img\构造2.png)

![构造3](D:\Files\VS-code\c and c++\Data Structure\Search\img\构造3.png)

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\构造4.png" alt="构造4" style="zoom:105%;" />

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\构造5.png" alt="构造5" style="zoom:100%;" />

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\构造6.png" alt="构造6" style="zoom:90%;" />



**特性：**

- 判定树结点关键字：左<中<右，满⾜⼆叉排序树的定义
- 只有最下⾯⼀层是不满的，树⾼h = ⌈log2(n + 1)⌉
- 失败结点：n+1个（等于成功结点的空链域数量）
- 若 mid = ⌊(low + high)/2⌋，则对于任何⼀个结点，必有： ==右⼦树结点数-左⼦树结点数=0或1==

### 3、分块查找（很少考代码）

​	**分块查找**，也叫索引顺序查找，算法实现除了需要查找表本身之外，还需要根据查找表建立一个索引表。例如下图，给定一个查找表，其对应的索引表如图所示：

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\分块查找.png" alt="分块查找" style="zoom:80%;" />

特点：块内⽆序、块间有序

**查找过程：**

​	 ①在索引表中确定待查记录所属的分块（可顺序、可折半）

​	 ②在块内顺序查找

**查找效率分析：** 

ASL = 查索引表的平均查找长度 + 查分块的平均查找长度

![分块查找ASL1](D:\Files\VS-code\c and c++\Data Structure\Search\img\分块查找ASL1.png)

![分块查找ASL2](D:\Files\VS-code\c and c++\Data Structure\Search\img\分块查找ASL2.png)

## 二、动态查找表

### 1、B树

#### 1.1 什么是B树

下图为一颗5阶B树：

<img src="D:\Files\VS-code\c and c++\Data Structure\Search\img\B树.png" alt="B树" style="zoom: 67%;" />

m阶B树的特性： 

​	1）树中每个结点⾄多有m棵⼦树，即⾄多含有m-1个关键字。 

​	2）若根结点不是终端结点，则⾄少有两棵⼦树。 

​	3）除根结点外的所有⾮叶结点⾄少有 ⌈m/2⌉ 棵⼦树，即⾄少含有 ⌈m/2⌉-1个关键字。

​	4）所有⾮叶结点的结构如下： 

​	![非叶节点结构](D:\Files\VS-code\c and c++\Data Structure\Search\img\非叶节点结构.png)

​	其中，Ki（i = 1, 2,…, n）为结点的关键字，且满⾜==K1 < K2 <…< Kn==；Pi（i = 0, 1,…, n）为指向⼦树根结点 的指针，且指针==Pi-1所指⼦树中所有结点的关键字均⼩于Ki==，==Pi所指⼦树中所有结点的关键字均⼤于Ki==，n （⌈m/2⌉- 1≤n≤m - 1）为结点中关键字的个数。 

​	5）所有的叶结点都出现在同⼀层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失 败结点，实际上这些结点不存在，指向这些结点的指针为空）。

![B树树高](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树树高.png)

#### 1.2 B树的插入和删除

**插入：** 

插入过程：

​	1️⃣ 根据要插入的key的值，找到叶子结点并插入。

​	2️⃣ 判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。

​	3️⃣ 以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

以5阶B树为例，每个节点最多含有4个关键字

1）在空树中插入39

![B树1](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树1.png)

此时根结点就一个key，此时根结点也是叶子结点

2）继续插入22，97和41

![B树2](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树2.png)

根结点此时有4个key

3）继续插入53

![B树3](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树3.png)

插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。

![B树4](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树4.png)

4）依次插入13，21，40，同样会造成分裂。

![B树5](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树5.png)

5）依次插入30，27, 33 ；36，35，34 ；24，29，

![B树6](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树6.png)

6）插入key值为26的记录，

![B树7](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树7.png)

当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点

![B树8](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树8.png)

进位后导致根结点也需要分裂，

![B树9](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树9.png)

分裂后当前结点指向新的根，此时无需调整。

7）最后再依次插入key为17,28,29,31,32的记录。

![B树10](D:\Files\VS-code\c and c++\Data Structure\Search\img\B树10.png)

**删除：** 

删除过程：

​	1️⃣ 如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步

​	2️⃣ 该结点key个数大于等于(m/2)-1，结束删除操作，否则执行第3步。

​	3️⃣ 如果兄弟结点key个数大于(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

以5阶B树为例，每个节点最多含有4个关键字

1）原始状态

![B删除1](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除1.png)

2）在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。

![B删除2](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除2.png)

3）接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。

![B删除3](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除3.png)

删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。

![B删除4](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除4.png)

4）接着删除32。

![B删除5](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除5.png)

当删除后，当前结点中只有1个key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。

![B删除6](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除6.png)

当前结点key的个数满足条件，故删除结束。

5）删除key为40的记录，

![B删除7](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除7.png)

同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。

![B删除8](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除8.png)

同理，对于当前结点而言只能继续合并了，

![B删除9](D:\Files\VS-code\c and c++\Data Structure\Search\img\B删除9.png)

合并后结点当前结点满足条件，删除结束。

### 2、B+树（一般只考基本概念）

如图所示

![B+树](D:\Files\VS-code\c and c++\Data Structure\Search\img\B+树.png)

⼀棵m阶的B+树需满⾜下列条件： 

1）每个分⽀结点最多有m棵⼦树（孩⼦结点）。 

2）⾮叶根结点⾄少有两棵⼦树，其他每个分⽀结点⾄少有  ⌈m/2⌉ 棵⼦树。 

3）结点的⼦树个数与关键字个数相等。 

4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按⼤⼩顺序排列，并且相邻叶结点按⼤⼩顺序相互链接起来。 

5）所有分⽀结点中仅包含它的各个⼦结点中关键字的最⼤值及指向其⼦结点的指针。

![B+树例子](D:\Files\VS-code\c and c++\Data Structure\Search\img\B+树例子.png)

在B+树中，⾮叶结点不含有该关键字对应记录的存储地址。 可以使⼀个磁盘块可以包含更多个关键字，使得B+树的阶更⼤，树⾼更矮， 读磁盘次数更少，查找更快。==B+树的查找操作，无论查找成功与否，每次查找操作都是走了一条从根结点到叶子结点的路径。==  

典型应⽤：关系型数据库的“索引”（如MySQL） 

**B+树和B树的对比：**

![对比](D:\Files\VS-code\c and c++\Data Structure\Search\img\对比.png)

## 三、哈希表（散列表）

哈希表可以通过关键字直接找到数据的存储位置，不需要进行任何的比较，其查找的效率较高的。

### 1、什么是哈希表

​	哈希表（Hash Table），⼜称散列表表。是⼀种数据结构，特点是：数据元素的关键字与其 存储地址直接相关

​	哈希表的建立同函数类似，把函数中的 x 用查找记录时使用的关键字来代替，然后将关键字的值带入一个精心设计的公式中，就可以求出一个值，用这个值来表示记录存储的哈希地址。即：

<div align = "center">数据的哈希地址=f（关键字的值）</div>

哈希地址只是表示在查找表中的存储位置，而不是实际的物理存储位置。f（）是一个函数，通过这个函数可以快速求出该关键字对应的的数据的哈希地址，称之为“哈希函数”。

例如，这里有一个电话簿（查找表），电话簿中有 4 个人的联系方式（ Index=Hash（key））：

| Index | key  | 手机号      |
| ----- | ---- | ----------- |
| 1     | 张三 | 13567827894 |
| 2     | 李四 | 12342233323 |
| 3     | 王五 | 19037452839 |
| 4     | 赵六 | 15673826213 |
| ...   |      | ...         |

​	假如想要查找张三的手机号，按照通常方法，需要从头到尾遍历，而通过构建哈希表，使用哈希函数带入key，就可以直接通过编号 1 来找到张三的手机号。

​	在构建哈希表时，最重要的是哈希函数的设计。有时，通过一个哈希函数带入不同的 key 可能会产生相同的 Index ，这种现象称为==冲突==，而这个key，叫做==同义词==在设计哈希函数时，要尽量地避免冲突现象的发生。（对于哈希表而言，冲突只能尽可能地少，无法完全避免。）

### 2、哈希表的构建

常用的哈希函数的构造方法：除留余数法、直接定址法、数字分析法和平方取中法。散列查找是典型的==“⽤空间换时间”==的算法，只要散列函数设计的合理，则散列表越⻓，冲突的概率越低。

#### 除留取余法

H(key) = key % p

​	散列表表⻓为m，取⼀个不⼤于m但最接近或等于m的==质数p==（质数⼜称素数。指除了1和此整数⾃ 身外,不能被其他⾃然数整除的数）

`⽤质数取模，分布更均匀，冲突更少`

例：散列表表⻓13，散列函数 H(key)=key%13

![m=13](D:\Files\VS-code\c and c++\Data Structure\Search\img\m=13.png)

例：散列表表⻓15，散列函数 H(key)=key%13。（最后两个不存放数据）

![m=15](D:\Files\VS-code\c and c++\Data Structure\Search\img\m=15.png)

#### 直接定址法

H(key) = key 或 H(key) = a*key + b

​	其中，a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。它适合==关键字的分布基本连续==的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

例：存储同⼀个班级的学⽣信息，班内学⽣学号为(1120112176~1120112205) H(key) = key - 1120112176

![直接定址](D:\Files\VS-code\c and c++\Data Structure\Search\img\直接定址.png)

#### 数字分析法

选取数码分布较为均匀的若⼲位作为散列地址

​	设关键字是r进制数（如⼗进制数），⽽==r 个数码在各位上出现的频率不⼀定相同，可能在某些位上分布均匀⼀些==，每种数码出现的机会均等；⽽在某些位上分布不均匀，只有某⼏种数码经常出现，此时可选取数码分布较为均匀的若⼲位作为散列地址。这种⽅法适合于已知的关键字集合， 若更换了关键字，则需要重新构造新的散列函数。

例：以“⼿机号码”作为关键字设计散列函数

![数字分析](D:\Files\VS-code\c and c++\Data Structure\Search\img\数字分析.png)

#### 平⽅取中法

取关键字的平⽅值的中间⼏位作为散列地址。 

​	具体取多少位要视实际情况⽽定。这种⽅法得到的==散列地址与关键字的每位都有关系==，因此使得散列地址分布⽐较均匀，适⽤于关键字的每位取值都不够均匀或均⼩于散列地址所需的位数。

例：要存储整个学校的学⽣信息，以“身份证号”作为关键字设计散列函数。

![平方取中](D:\Files\VS-code\c and c++\Data Structure\Search\img\平方取中.png)



### 3、处理冲突的方法与查找

#### 拉链法

把所有“同义词”存储在⼀个链表中

![拉链法](D:\Files\VS-code\c and c++\Data Structure\Search\img\拉链法.png)

对于使用拉链法的平均查找长度：
$$
ASL_{成功}=\frac{1 \times6+2\times3+4\times1+5\times1}{12}=1.75
$$

$$
ASL_{失败}=\frac{0 + 4 + 0 + 2 + 0 + 0 + 2 + 1 + 0 + 0 + 2 + 1 + 0}{13}=0.92
$$

ASL_失败= ==装填因子== 
$$
装填因⼦α=\frac{表中记录数}{散列表⻓度}
$$
装填因⼦会直接影响 散列表的查找效率。

#### 开放定址法

指可存放新表项的空闲地址既向它的同义词表项开放，⼜向它的⾮同义词表项开放。其数学递推公式为：
$$
H_i = (H(key) + d_i) \% m
$$

$$
i = 0, 1, 2,…, k（k≤m - 1），m表示散列表表⻓；d_i为增量序列；i 可理解为“第i次发⽣冲突”
$$

主要有3种方法：

##### 	1.线性探测法：⭐⭐⭐  

​	d_i = 0, 1, 2, 3, …, m-1；即发⽣冲突时，每次往后探测相邻的下⼀个单元是否为空。

处理过程：

![线1](D:\Files\VS-code\c and c++\Data Structure\Search\img\线1.png)

1）插入1，H(key)=1%13=1，发生冲突，后重新计算得到的哈希地址。

![线2](D:\Files\VS-code\c and c++\Data Structure\Search\img\线2.png)

H_0=(1+d_0)%16=1  冲突   H_1=(1+d_1)%16=2   放入2位置

![线3](D:\Files\VS-code\c and c++\Data Structure\Search\img\线3.png)

2) 插入68、20

![线4](D:\Files\VS-code\c and c++\Data Structure\Search\img\线4.png)

3）插入84，H(key)=84%13=6，发生冲突，H0=(6+0)%16=6  冲突 H1=(6+1)%16=7 冲突  H2=8 放入8位置

![线5](D:\Files\VS-code\c and c++\Data Structure\Search\img\线5.png)

4）插入27，H(key)=27%13=1   H1=2 冲突 H2=3 冲突 H3=4 放入4位置

![线6](D:\Files\VS-code\c and c++\Data Structure\Search\img\线6.png)

5）插入55，H(key)=55%13=3   H1=4 冲突 H2=5 放入5位置

![线7](D:\Files\VS-code\c and c++\Data Structure\Search\img\线7.png)

6）插入11.

![线8](D:\Files\VS-code\c and c++\Data Structure\Search\img\线8.png)

7）插入10，H(key)=10%13=10 冲突 H1=11 冲突 H2=12位置

![线9](D:\Files\VS-code\c and c++\Data Structure\Search\img\线9.png)

8）插入79，H(key)=79%13=1 68 20 84 H1=2 冲突 H2=3 冲突   （依次探测...） H8=9 放入9位置

![线10](D:\Files\VS-code\c and c++\Data Structure\Search\img\线10.png)

9）插入25，H(25)=25%13 = 12  冲突  H1=(H(key)+1)%16 = 13  放入13位置

![线11](D:\Files\VS-code\c and c++\Data Structure\Search\img\线11.png)

所有关键字转换结束结束。

![线12](D:\Files\VS-code\c and c++\Data Structure\Search\img\线12.png)

- ​	查找操作过程：
  - 对于给定的key，计算hash地址index = H（key）
  - 如果数组arr【index】的值为空 则查找不成功
  - 如果数组arr【index】== key 则查找成功
  - 否则 使用线性探测法求下一个地址，直到arr【index】== key或者 arr【index】==null

- 删除操作：

  ​		先查找，找到后删除，删除结点==不能简单地将被删结点的空间置为空==，否则将截断在它之后填⼊散列表的同义词结点的查找路径，==可以做⼀个“删除标记”==，进⾏逻辑删除

- 查找效率分析：

  ​		
  $$
  ASL_{成功}=\frac{1 + 1 + 1 + 2 + 4 + 1 + 1 + 3 + 3 + 1 + 3 + 9
  }{12}=2.5
  $$

  $$
  ASL_{失败}=\frac{1 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2}{13}=7
  $$

线性探测法很容易造成同义词、⾮同义词的“聚集（堆积）”现象，严重影响查找效率 产⽣原因——冲突后再探测⼀定是放在某个连续的位置

##### 	2、平方探测法：  

当di = 02, 12, -12, 22, -22, …, k2, -k2时，称为平⽅探测法，⼜称⼆次探测法其中k≤m/2

`散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置`

过称类似上面线性探测法，只不过换了d。

##### 	3、伪随机数列： 

di 是⼀个伪随机序列，如 di= 0, 5, 24, 11, …

#### 再散列法

​	除了原始的散列函数 H(key) 之外，多准备⼏个散列函数， 当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌：
$$
H_i=RH_i(key)
$$

### 4、查找算法的效率分析

在构造哈希表的过程中，由于冲突的产生，使得哈希表的查找算法仍然会涉及到比较的过程，因此对于哈希表的查找效率仍需以平均查找长度来衡量。

在哈希表的查找过程中需和给定值进行比较的关键字的个数取决于以下 3 个因素：

- 哈希函数：哈希函数的“好坏”取决于影响出现冲突的频繁程度。但是一般情况下，哈希函数相比于后两种的影响，可以忽略不计。
- 处理冲突的方式：对于同一组关键字，设定相同的哈希函数，使用不同的处理冲突的方式得到的哈希表是不同的，表的平均查找长度也不同。
- 哈希表的装填因子：在一般情况下，当处理冲突的方式相同的情况下，其平均查找长度取决于哈希表的装满程度：装的越满，插入数据时越有可能发生冲突；反之则越小。

> 装填因子=哈希表中数据的个数/哈希表的长度，用字符 α 表示（是数学符号，而不是字符 a）。装填因子越小，表示哈希表中空闲的位置就越多。

经过计算，在假设查找表中的所有数据的查找概率相等的情况下，对于表长为 m，数据个数为 n 的哈希表：

- 其查找成功的平均查找长度约为：-1/α * ln⁡(1-α)
- 其查找不成功的平均查找长度约为：1/(1-α)

通过公式可以看到，哈希表的查找效率只同装填因子有关，而同哈希表中的数据的个数无关，所以在选用哈希表做查找操作时，选择一个合适的装填因子是非常有必要的。

