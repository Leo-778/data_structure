# 图

## 图的存储

### 邻接矩阵（顺序存储）

无向图和有向图是一样的，缺点是空间复杂度高

#### 不带权

```
  A  B  C  D
A 0  0  1  0
B 0  0  0  0
C 1  0  0  0
D 0  0  0  0
```

二维数组

```c++
#define MaxVertexNum 100
typedef struct{
    char Vex[MaxVertexNum];//顶点的信息 V = {v1,v2,v3,...,vn}
    int Edge[MaxVertexNum][MaxVertexNum];//边的信息  E = { (v1,v2),(v1,v3),...}
    int vexnum,arcnum;//图当前顶点数和边数
}MGraph;
```

无向图求顶点的度：

遍历那一行（或那一列）非零元素的个数，时间复杂度 $O(n)$ 。

有向图顶点的度：

出度：那一行 非零元素的个数

入度：那一列 非零元素的个数

度：行➕列；非零元素    时间复杂度 $O(n)$ 。

#### 带权

我们把不存在路径的用正无穷表示，这里用'-'表示，例如A到C的边权重是8，

```
  A  B  C  D
A -  -  8  -
B -  -  7  -
C 8  7  -  5
D -  5  -  -
```

代码

```c++
#define MaxVertexNum 100
#define INFINITY 最大的int值    //宏定义常量"无穷"
typedef char VertexType;
typedef int EdgeType;
typedef struct{
    VertexType Vex[MaxVertexNum];//顶点的信息 V = {v1,v2,v3,...,vn}
    EdgeType Edge[MaxVertexNum][MaxVertexNum];//边的权  E = { (v1,v2),(v1,v3),...}
    int vexnum,arcnum;//图当前顶点数和弧数
}MGraph;
```

#### 性能分析

空间复杂度 $O(n^2)$  ==适合存储稠密图== 

无向图的邻接矩阵是 ==对称矩阵== ，可以用对称矩阵的法索存储，只存储上三角或下三角。

![对称矩阵的压缩](D:\Files\VS-code\c and c++\Data Structure\graph\img\对称矩阵的压缩.png)

#### 性质

![LJ性质](D:\Files\VS-code\c and c++\Data Structure\graph\img\LJ性质.png)

设 图 $ G $ 的邻接矩阵为 $A$  (矩阵元素为 $0/1$ )，则 $A^n$ 的元素 $A_{[i][j]}$ 等于由顶点 $i$ 到顶点 $j$ 的长度为 $ n$ 的==路径 的 数目== 

​		例：$A^2_{[1][4]}= 1$ 表示从 A 到 D 长度为 2 的路径总数为 1

### 邻接表（顺序存储➕链式存储）

  ==邻接表适合存储稀疏图== 

#### 无向图

缺点：每条边对应两份冗余信息，删除顶点、删除边等操作时间复杂度高

![邻接表的存储](D:\Files\VS-code\c and c++\Data Structure\graph\img\邻接表的存储.png)

代码实现

```c++
//用邻接表存储的图
typedef struct{
	AdjList vertices;
    int vexnum,arcnum;
}ALGraph;
//“顶点”
typedef struct VNode{
	VertexType data;//顶点信息
    ArcNode *first;//第一条边/弧
}VNode,AdjList[MaxVertexNum];
//"边/弧"
typedef struct ArcNode{
    int adjves;   //边/弧指向那一个结点
    struct ArcNode *next;//指向下一条弧的指针
    //InfoType info;//边权值
}ArcNode;
```

边的数量是 $2|E|$ 

空间复杂度 $O（|V|+2|E|）$  

度：遍历这个结点的边链表。

#### 有向图

![有向图邻接表存储](D:\Files\VS-code\c and c++\Data Structure\graph\img\有向图邻接表存储.png)

边的数量是 $|E|$ 

空间复杂度 $O（|V|+|E|）$  

出度：遍历这个结点的边链表。

入度：遍历所有结点的边链表

### 十字链表（存储有向图）

![十字链表存储](D:\Files\VS-code\c and c++\Data Structure\graph\img\十字链表存储.png)



### 邻接多重表（存储无向图）

删除边、删除结点会很方便

### 对比

![四种方式对比](D:\Files\VS-code\c and c++\Data Structure\graph\img\四种方式对比.png)

## 基本操作（邻接矩阵和邻接表）

**Adjacent(G,x,y)：** 判断图G是否存在边 $<x,y>$ 或 $ (x,y)$ 。

**Neighbors(G,x)：** 列出图G中与结点x邻接的边。

**InsertVertex(G,x)：** 在图G中插入顶点x。

**DeleteVertex(G,x)：**从图G中删除顶点x。

**AddEdge(G,x,y)：**若无向边 $(x, y)$ 或有向边 $<x,y>$ 不存在，则向图G中添加该边。

**RemoveEdge(G,x,y)：**若无向边 $(x, y)$ 或有向边 $<x,y>$ 存在，则从图G中删除该边。

 ==**FirstNeighbor(G,x)：**==求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点 或图中不存在x，则返回-1。

 ==**NextNeighbor(G,x,y)：**==假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一 个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。

**Get_edge_value(G,x,y)：**获取图G中边 $(x, y)$ 或 $<x,y>$ 对应的权值。

**Set_edge_value(G,x,y,v)：**设置图G中边 $(x, y)$ 或 $<x,y>$ 对应的权值为v。

图的遍历： ==深度优先遍历== 、==广度优先遍历== 

