# 图

## 一、图的定义及术语

### 1、基本术语

- **无向图** ：若E是无向边（简称边）的有限集合时，则图G为无向图（==边是没有方向的==）。记为(v,w )，边==(v, w) = (w, v)==，v、w是顶点。

- **有向图** ：若E是有向边（也称弧）的有限集合时，则图G为有向图（==边是有方向的== ）。 记为<v,w>，边<v,w> != <w,v>，v称为==弧尾==，w称为==弧头== 

- **简单有向、无向图** ：不存在重复边，不存在顶点到自身的边。

- **多重有向、无向图** ：两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联。

- **顶点的度（无向图） ** ：顶点v的度是指依附于该顶点的边的条数，记为 $TD(v)$ 。 所有顶点的度之和=2|E|

- **出度（有向图）** ：以顶点v为终点的有向边的数目，记为 $ID(v)$；

- **入度（有向图）** ：以顶点v为起点的有向边的数目，记为 $OD(v)$ 。有向图的度=出度+入度。

- **路径** ：—顶点 $V_p$ 到顶点 $V_q$ 之间的一条路径是指顶点序列 ,$V_p,V_{i_1},V_{i_2},...,V_{i_n},V_q$ 

- **回路** ：第一个顶点和最后一个顶点相同的路径称为回路或环

- **简单路径** ：在路径序列中，顶点不重复出现的路径称为简单路径。

- **简单回路** ：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。

- **路径长度** ：路径上边的数目

- **点到点的距离** ：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。 若从u到v根本不存在路径，则记该距离为无穷（$\infty$ ）。

- **连通** ：无向图中，若从顶点v到顶点w有路径存在，则称v和w是 ==连通==的

- **强连通** ：有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是===强连通==的

- **连通图、非连通图** ：若图G中任意两个顶点都是连通的，则称图G为 连通图，否则称为非连通图。 

  - 对于n个顶点的无向图G， 

    若G是==连通图==，则==最少==有 $n-1$ 条边 

    若G是==非连通图==，则==最多==可能有 $C^{2}_{n-1}$ 条边

- **强连通图** ：若图中任何一对顶点都是强连通的，则称此图为 强连通图。

  - 对于n个顶点的有向图G，

    若G是强连通图，则最少有 n 条边（形成回路）

- **子图** ：设有两个图G = (V, E)和G' = (V', E')，若V'是V的子集，且E'是 E的子集，则称G'是G的子图。

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\子图.png" alt="子图" style="zoom:80%;" />

- **生成子图** ：若有满足V(G') = V(G)的子图G'，则称其为G的生成子图

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\生成子图.png" alt="生成子图" style="zoom:80%;" />

- **连通分量** ：无向图中的极大连通子图称为连通分量。

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\连通分量.png" alt="连通分量" style="zoom:80%;" />

- **强连通分量** ：有向图中的极大强连通子图称为有向图的强连通分量。

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\强连通分量.png" alt="强连通分量" style="zoom:80%;" />

- **生成树** ：包含图中全部顶点的一个极小连通子图（边要尽可能少，但要保持连通）

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\生成树.png" alt="生成树" style="zoom:80%;" />

- **生成森林 ** ：在非连通图中，连通分量的生成树构成了非连通图的生成森林。

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\生成森林.png" alt="生成森林" style="zoom:70%;" />

- **边的权** ：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。

- **带权图/网** ：边上带有权值的图称为带权图，也称网。
- **带权路径长度** ：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度。
- **稀疏图** ：边数很少的图
- **稠密图** ：边数很多的图

### 2、常见考点

**对于n个顶点的==无向图==G** 

- 所有顶点的度之和 = 2 |E|。
- 若G是连通图，则最少有 n - 1 条边（树）， 若 |E| > n - 1，则一定有回路
- 若G是非连通图，则最多可能有 $ C^{2}_{n-1}$  条边 
- 无向完全图共有 $ C^{2}_{n}$ 边

**对于n个顶点的==有向图==G** 

- 所有顶点的出度之和 = 入度之和 = |E| 。
- 所有顶点的度之和 = 2 |E| 。
- 若G是强连通图，则最少有 n 条边（形成回路）
- 有向完全图共有 $2 C^{2}_{n}$ 边

## 二、图的存储

### 1、邻接矩阵（顺序存储）

无向图和有向图是一样的，缺点是空间复杂度高

#### 不带权

```
  A  B  C  D
A 0  0  1  0
B 0  0  0  0
C 1  0  0  0
D 0  0  0  0
```

二维数组

```c++
#define MaxVertexNum 100
typedef struct{
    char Vex[MaxVertexNum];//顶点的信息 V = {v1,v2,v3,...,vn}
    int Edge[MaxVertexNum][MaxVertexNum];//边的信息  E = { (v1,v2),(v1,v3),...}
    int vexnum,arcnum;//图当前顶点数和边数
}MGraph;
```

无向图求顶点的度：

遍历那一行（或那一列）非零元素的个数，时间复杂度 $O(n)$ 。

有向图顶点的度：

出度：那一行 非零元素的个数

入度：那一列 非零元素的个数

度：行➕列；非零元素    时间复杂度 $O(n)$ 。

#### 带权

我们把不存在路径的用正无穷表示，这里用'-'表示，例如A到C的边权重是8，

```
  A  B  C  D
A -  -  8  -
B -  -  7  -
C 8  7  -  5
D -  5  -  -
```

代码

```c++
#define MaxVertexNum 100
#define INFINITY 最大的int值    //宏定义常量"无穷"
typedef char VertexType;
typedef int EdgeType;
typedef struct{
    VertexType Vex[MaxVertexNum];//顶点的信息 V = {v1,v2,v3,...,vn}
    EdgeType Edge[MaxVertexNum][MaxVertexNum];//边的权  E = { (v1,v2),(v1,v3),...}
    int vexnum,arcnum;//图当前顶点数和弧数
}MGraph;
```

#### 性能分析

1、空间复杂度 $O(n^2)$  ==适合存储稠密图== 

2、无向图的邻接矩阵是 ==对称矩阵== ，可以用对称矩阵的压缩存储，只存储上三角或下三角。

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\对称矩阵的压缩.png" alt="对称矩阵的压缩" style="zoom:80%;" />

#### 性质

![LJ性质](D:\Files\VS-code\c and c++\Data Structure\graph\img\LJ性质.png)

设 图 $ G $ 的邻接矩阵为 $A$  (矩阵元素为 $0/1$ )，则 $A^n$ 的元素 $A_{[i][j]}$ 等于由顶点 $i$ 到顶点 $j$ 的==长度为n== 的 ==路径 的 数目== 

​		例：$A^2_{[1][4]}= 1$ 表示从 A 到 D 长度为 2 的路径总数为 1

### 2、邻接表（顺序存储➕链式存储）

  ==邻接表适合存储稀疏图== 

#### 无向图

缺点：每条边对应两份冗余信息，删除顶点、删除边等操作时间复杂度高

![邻接表的存储](D:\Files\VS-code\c and c++\Data Structure\graph\img\邻接表的存储.png)

代码实现

```c++
//用邻接表存储的图
typedef struct{
	AdjList vertices;
    int vexnum,arcnum;
}ALGraph;
//“顶点”
typedef struct VNode{
	VertexType data;//顶点信息
    ArcNode *first;//第一条边/弧
}VNode,AdjList[MaxVertexNum];
//"边/弧"
typedef struct ArcNode{
    int adjves;   //边/弧指向那一个结点
    struct ArcNode *next;//指向下一条弧的指针
    //InfoType info;//边权值
}ArcNode;
```

边的数量是 $2|E|$ 

空间复杂度 $O（|V|+2|E|）$  

度：遍历这个结点的边链表。

#### 有向图

![有向图邻接表存储](D:\Files\VS-code\c and c++\Data Structure\graph\img\有向图邻接表存储.png)

边的数量是 $|E|$ 

空间复杂度 $O（|V|+|E|）$  

出度：遍历这个结点的边链表。

入度：遍历所有结点的边链表

### 3、十字链表（存储有向图）

![十字链表存储](D:\Files\VS-code\c and c++\Data Structure\graph\img\十字链表存储.png)



### 4、邻接多重表（存储无向图）

删除边、删除结点会很方便

### 对比

![四种方式对比](D:\Files\VS-code\c and c++\Data Structure\graph\img\四种方式对比.png)

## 三、基本操作（邻接矩阵和邻接表）

**Adjacent(G,x,y)：** 判断图G是否存在边 $<x,y>$ 或 $ (x,y)$ 。

**Neighbors(G,x)：** 列出图G中与结点x邻接的边。

**InsertVertex(G,x)：** 在图G中插入顶点x。

**DeleteVertex(G,x)：**从图G中删除顶点x。

**AddEdge(G,x,y)：**若无向边 $(x, y)$ 或有向边 $<x,y>$ 不存在，则向图G中添加该边。

**RemoveEdge(G,x,y)：**若无向边 $(x, y)$ 或有向边 $<x,y>$ 存在，则从图G中删除该边。

 ==**FirstNeighbor(G,x)：**==求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点 或图中不存在x，则返回-1。

 ==**NextNeighbor(G,x,y)：**==假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一 个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。

**Get_edge_value(G,x,y)：**获取图G中边 $(x, y)$ 或 $<x,y>$ 对应的权值。

**Set_edge_value(G,x,y,v)：**设置图G中边 $(x, y)$ 或 $<x,y>$ 对应的权值为v。

图的遍历： ==深度优先遍历== 、==广度优先遍历== 

## 四、图的遍历

### 1、广度优先遍历（BFS):

#### 1.1 代码实现

```c++
bool visited[MAX_VERTEX_NUM];    //访问标记数组
void BFS(MGraph G,int V){
    visit(V);                    //访问初始顶点v
    visited[V]=true;             //对v作已访问标记
    EnQueue(Q,V);                //顶点v出队列
    while(!IsEmpty(Q)){
        DeQueue(Q, V);            //顶点v出队列
        for (w=FirstNeighbor(G,V); w>0; w=NextNeighbor(G,V,w)){//检测v所有邻接点
            if (!visited[w]){           //w为v的尚未访问的临界顶点
                visit(w);               //访问顶点w
                visited[w] = true;      //对w作已访问标记
                EnQueue(Q, V);          //顶点w入队列
            }
        }
    }
}

void BFSTraverse(MGraph G){      
    for (int i = 0; i < G.vexnum; ++i)
        visited[i] = false;      //访问标记数组初始化
    InitQueue(Q);                //初始化辅助队列Q
    for (int i = 0; i < G.vexnum; ++i)   //从0号顶点开始遍历
        if(!visited[i])              //对每个连通分量调用依次BFS
            BFS(G, i);               //vi未访问过，从vi开始BFS
}
```

#### 1.2 时间、空间复杂度

空间复杂度：最坏情况，辅助队列⼤⼩为 O(|V|)

邻接矩阵存储的图：时间复杂度= O(|V|2)

邻接表存储的图：时间复杂度= O(|V|+|E|)

#### 1.3 ⼴度优先⽣成树、森林

广度优先生成树

![广度优先生成树](D:\Files\VS-code\c and c++\Data Structure\Graph\img\广度优先生成树.png)

广度优先生成森林

![广度优先生成森林](D:\Files\VS-code\c and c++\Data Structure\Graph\img\广度优先生成森林.png)

### 2、深度优先遍历(DFS)

#### 2.1 代码实现

```c++
bool visited[MAX_VERTEX_NUM];    //访问标记数组
void DFS(MGraph G,int V){
    visit(V);                    //访问初始顶点v
    visited[V]=true;             //对v作已访问标记
    while(!IsEmpty(Q)){
        for (w=FirstNeighbor(G,V); w>0; w=NextNeighbor(G,V,w)){//检测v所有邻接点
            if (!visited[w]){           //w为v的尚未访问的临界顶点
                DFS(G,w);
            }
        }
    }
}

void DFSTraverse(MGraph G){      
    for (int i = 0; i < G.vexnum; ++i)
        visited[i] = false;      //访问标记数组初始化
    for (int i = 0; i < G.vexnum; ++i)   //从0号顶点开始遍历
        if(!visited[i])              //对每个连通分量调用依次BFS
            BFS(G, i);               //vi未访问过，从vi开始BFS
}
```



#### 2.2 时间、空间复杂度

空间复杂度：来⾃函数调⽤栈，最坏情况，递归深度为O(|V|)，最好情况，O(1)

时间复杂度：邻接矩阵存储的图：时间复杂度= O(|V|2)

​                     邻接表存储的图：时间复杂度= O(|V|+|E|)

==时间复杂度=访问各结点所需时间➕探索各条边所需时间==  

#### 2.3 深度优先生成树、森林

同⼀个图的==邻接矩阵==表示⽅式==唯⼀==，因此深度优先遍历序列==唯⼀==，深度优先⽣成树也==唯⼀==  

同⼀个图==邻接表==表示⽅式==不唯⼀==，因此深度优先遍历序列==不唯⼀==，深度优先⽣成树也==不唯⼀== 

下图为  图及其对应的深度优先生成森林。

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\1.png" alt="1" style="zoom:75%;" />

<img src="D:\Files\VS-code\c and c++\Data Structure\Graph\img\2.png" alt="2" style="zoom:67%;" />

### 五、最小生成树（无向图）

#### 1、最小生成树及其性质

​	对于⼀个带权连通⽆向图 $G = (V, E)$ ，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中==边的权值之和最⼩==的⽣成树，则 $T$ 称为 $G$ 的==最⼩⽣成树（*Minimum-Spanning-Tree, MST*）==。

最小生成树具有以下性质：

- 最小生成树，其边数等于顶点树减 1 ，且树内一定不会有环。
- 对给定的图 $G(V,E)$ 其最小生成树可以不唯一，但其边权值之和一定唯一。
- 最小生成树是在无向图生成的，故其根节点可以是树上任意节点。

#### 2、prim（普里姆）算法

基本思想：

​	对图 $G（V，E）$ 设置集合 S ，存放已经被访问的顶点，然后每次从集合V-S中选择与集合S的距离最小的一个顶点（记为u），访问并加入集合S。之后，令顶点u为中介点，优化所有能从u到达顶点v与集合S之间的最短距离。执行操作n次，直到集合S中包含所有顶点。

代码需要解决的问题：

1. 集合S的实现
2. 顶点 $V_i$ 与集合S的最短距离。

解决思路：

1. 集合S：使用一个bool型数组 isJoin[ ]表示顶点是否已被访问。其中 isJoin[ i ] = true 表示顶点 $V_i$  已被访问， isJoin[ i ] = false 表示顶点 $V_i$  还未被访问。
2. 最短距离：令int型的数组 lowCost[ ]存放顶点 $V_i$ 与集合S的最短距离。初始时 lowCost[s]赋为0，其余为无穷（一个很大的数 INF）。

代码实现（伪代码）：

```c++
//G为图，一般设置成全局变量；数组d为顶点与集合s的最短距离
Prim(G,d[]){
    初始化;
    for(循环n次){
        u = 使得d[u]最小的还未被访问的顶点的标号;
        记u已被访问;
        for(从u出发能达到的所有顶点v){
            if(v未被访问 && 以u为中介点使得v与集合S的最短距离d[v]更优){
				将G[u][v]赋值给v与集合S的最短距离d[v];
            }
        }
    }
}
```

代码实现（可运行）：

```c++
//邻接矩阵

#define MAXV  1000
#define INF  1000001

int n, G[MAXV][MAXV];//n是顶点个数，MAXV是最大顶点数
int d[MAXV];//顶点与集合S的最短距离
bool vis[MAXV] = {false};//标记数组未访问

int Prim(){//函数返回最小生成树的边权值之和
    for (int i = 1; i < MAXV;i++)//初始化数组d
        d[i] = INF;
    d[0] = 0;//只有0号顶点到集合S的距离为0，其余全为INF
    int ans = 0;//存放最小生成树的边权值之和
    for (int i = 0; i < n; i++)//循环n次
    {
        int u = -1, MIN = INF;//u使d[u]最小，MIN存放最小的d[u]
        for (int j = 0; j < n; j++)//找到未访问中d[u]最小的
        {
            if (vis[j] == false && d[j] < MIN)
            {
                u = j;
                MIN = d[j];
            } 
        }
        //
        if(u==-1)
            return -1;//找不到小于INF的，则剩下的点不连通
        vis[u] = true;//标记u为已访问
        ans += d[u];//将与集合S距离最小的边加入最小生成树
        for (int v = 0; v < n; v++)
        {
            if (vis[v] == false && G[u][v] != INF && G[u][v] < d[v])//v未访问&&u能到达v&&以u为中介点可以使v离集合s更近
                d[v] = G[u][v];//将G[u][v]赋值给d[v]
        }
    }
    return ans;//返回最小生成树的边权值和
}
//邻接表

```



#### 3、kruskal（克鲁斯卡尔）算法



### 六、最短路径

#### 1、BFS算法



#### 2、Dijkstra算法



#### 3、Floyd算法



### 七、拓扑排序

#### 1、有向无环图



#### 2、拓扑排序



### 八、关键路径

#### 1、AOV网和AOE网



#### 2、最长路径



#### 3、关键路径



