# 贪心算法

## 一、什么是贪心算法

​		贪心法是求解一类**最优化问题**的方法，它总是考虑达到每一阶段下的**局部最优**，从而逐步达到**全局最优**。

​		举个例子：例如，有⼀堆钞票，你能拿10次，每次最多只会能拿5张，如果要使拿到的金额最多，要怎么拿？肯定是每次拿最大的，结果肯定是拿到的金额最多。每次拿最⼤的就是局部最优，最后拿⾛最⼤数额的钱就是推出全局最优。

## 二、什么时候用贪心

​		**贪心策略适用的前提是：局部最优策略能导致产生全局最优解。**

​		显然，如果采取较优而非最优的策略（最优策略可能不存在或是不易想到)，得到的全局结果也无法是最优的。而要获得最优结果，则要求中间的每步策略都是最优的，因此严谨使用贪心法来求解最优化问题需要对采取的策略进行证明。证明的一般思路是使用**反证法**及**数学归纳法**，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。

​		不过对平常使用来说，也许没有时间或不太容易对想到的策略进行严谨的证明（贪心的证明往往比贪心本身更难)，因此一般来说，如果在想到某个似乎可行的策略，并且自己无法举出反例，那么就勇敢地实现它。

## 三、贪心算法的基本思路	

贪⼼算法⼀般分为如下四步： 

1. 将问题分解为若⼲个⼦问题 
2. 找出适合的贪⼼策略 
3. 求解每⼀个⼦问题的最优解 
4. 将局部最优解堆叠成全局最优解

贪心算法没有具体的套路和框架，具体问题还是需要具体分析。

## 四、经典例题

### 1、最优装载问题

**描述：**

给定n个货物及船只的最大载重maxweight，每件货物重$W_i$（下标从0开始），求怎么能够装载最多数量的货物到船上呢？并给出货物重量

**示例：**

```
输入：
船只的最大载重maxweight=30
给定货物数量n=8
重量分别为：W={4, 10, 7, 11, 3, 5, 14, 2}

输出：
5
2 3 4 5 7
```

**分析：**

​		这个问题是一个典型的可以使用贪心算法解决的问题。

​		通过分析题目可以看到，小船的载重量（MAXWEIGHT）是固定的，要求装载的物品数量最多，那么应该每次都选择最轻的，然后再从剩下的n-1件物品中选择最轻的，直到达到小船载重量的要求。

​		选择先装载重量最小的物品，这个选择策略就采用了贪心（Greedy）策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。

​		算法策略：把n件物品 从小到大排序，然后根据贪心策略尽可能多的选出前i个物品，直到不能装为止。

**代码实现：**

```c++
#include<stdio.h>
#include<algorithm>
ustart[i]ng namespace std;
//最优装载问题

const int maxweight = 30;//船只的最大载重
const int n = 8;//货物数量
int cnt = 0,p[n];//数组p用来存放可以放入的货物的重量

void maxloading(int *w,int n){
    int sum = 0;
    for (int i = 0; i < n; i++)
    {
        if (sum+w[i]<maxweight)
        {
            sum += w[i];
            cnt++;
            p[i] = w[i];
        }
        else
            break;
    }
}
int main(int argc, char const *argv[])
{
    int w[n] = {4, 10, 7, 11, 3, 5, 14, 2};
    sort(w, w + 8);//排序（从w[0]到w[7]排序）
    maxloading(w, n);
    printf("%d\n", cnt);
    for (int i = 0; i < cnt; i++)
    {
        printf("%d ", p[i]);
    }
    return 0;
}
```

### 2、活动安排

**描述：**

​		设有N个活动时间集合，每个活动都要使用同一个资源，比如说会议场，而且同一时间内只能有一个活动使用，每个活动都有一个使用活动的开始start[i]和结束时间end[i]，即他的使用区间为（start[i],end[i]）,现在要求你分配活动占用时间表，即哪些活动占用该会议室，哪些不占用，使得他们不冲突，要求是尽可能多的使参加的活动最大化，即所占时间区间最大化！

| i        | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| start[i] | 1    | 3    | 0    | 5    | 3    | 5    | 6    | 8    | 8    | 2    | 12   |
| end[i]   | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |

上表为每个活动的开始和结束时间，我们的任务就是安排资源给活动使用 使活动的数量最大，及输出每个活动的时间段。

**示例：**

```
输入：
活动的额数量n=11；
每个活动开始时间start[11]={1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
结束时间end[11]={4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
输出：
活动1 开始时间:1,结束时间:4
活动4 开始时间:5,结束时间:7
活动8 开始时间:8,结束时间:11
活动11 开始时间:12,结束时间:14
```

**思路：**

​		每个活i都有一个要求使用该资源的起始时间start[i]和一个结束时间end[i],且start[i] < end[i] 。如果选择了活动i，则它在半开时间区间[start[i], end[i])内占用资源。
​		若区间[start[i], end[i])与区间[start[j], end[j])不相交，则称活动i与活动j是相容的。也就是说，当start[i] >= end[j]或start[j] >= end[i]时，活动i与活动j相容。

​		算法策略是：每次总是选择具有最早完成时间的相容活动加入集合A中，

​		注：end数组已经是从小到大的了，题目简化了很多。

**代码实现：**

```c++
#include<stdio.h>

const int n = 11;
int used[n]={false};//数组used用来记录那个活动进行过

void greedySelector(int *start,int *end){
	used[0] = true;
	int j = 0;
	for (int i = 1; i < n; i++)
	{
		if (start[i]>end[j])//相容
		{
			used[i] = true;//标记使用
			j = i;
		}
	}
}

int main(int argc, char const *argv[])
{
	int start[11]={1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12};
	int end[11]={4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
	greedySelector(start, end);
	for (int i = 0; i < n; i++)
	{
		if (used[i]==true)
		{
			printf("活动 %d ", i+1);
			printf("开始时间：%d ;结束时间：%d \n", start[i], end[i]);
		}
		
	}
	return 0;
}
```



### 3、



### 4、



### 5、



